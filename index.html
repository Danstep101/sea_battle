<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Морской бой</title>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --accent: #e74c3c;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --ship: #95a5a6;
            --hit: #e74c3c;
            --miss: #3498db;
            --water: #c2e9fb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            touch-action: manipulation;
        }

        h1 {
            color: var(--dark);
            margin: 8px 0;
            text-align: center;
            font-size: clamp(1.5rem, 4vw, 2rem);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }

        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 8px 0;
            width: 100%;
            max-width: 1000px;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: calc(50% - 10px);
        }

        h2 {
            color: var(--dark);
            margin-bottom: 6px;
            font-size: clamp(1rem, 3vw, 1.2rem);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(10, minmax(20px, 30px));
            grid-template-rows: repeat(10, minmax(20px, 30px));
            gap: 1px;
            background-color: var(--water);
            border: 2px solid var(--primary);
            padding: 2px;
            border-radius: 4px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            width: 100%;
            aspect-ratio: 1/1;
        }

        .cell {
            width: 100%;
            height: 100%;
            background-color: var(--water);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 2px;
            user-select: none;
            -webkit-user-select: none;
        }

        .cell:hover {
            background-color: #a1d8f7;
        }

        .ship {
            background-color: var(--ship);
            border: 1px solid #7f8c8d;
        }

        .hit {
            background-color: var(--hit);
            color: white;
            position: relative;
        }

        .hit::after {
            content: '✖';
            position: absolute;
            font-size: 1rem;
        }

        .miss {
            background-color: var(--miss);
            color: white;
            position: relative;
        }

        .miss::after {
            content: '•';
            position: absolute;
            font-size: 1rem;
        }

        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 12px 0;
            width: 100%;
            max-width: 1000px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            width: 100%;
            max-width: 220px;
        }

        .message-box {
            padding: 8px;
            border-radius: 6px;
            background-color: var(--light);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
            min-height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            line-height: 1.3;
        }

        button {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: clamp(0.8rem, 3vw, 0.9rem);
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .ship-selector {
            background-color: var(--light);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 220px;
        }

        .ship-selector h3 {
            color: var(--dark);
            margin-bottom: 8px;
            font-size: clamp(0.9rem, 3vw, 1rem);
            text-align: center;
        }

        .ship-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 6px;
        }

        .ship-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
            font-size: clamp(0.7rem, 3vw, 0.8rem);
        }

        .ship-item:hover {
            background-color: #dfe6e9;
        }

        .ship-preview {
            display: flex;
            margin-right: 6px;
        }

        .ship-preview-cell {
            width: 16px;
            height: 16px;
            background-color: var(--ship);
            border: 1px solid #7f8c8d;
            margin-right: 1px;
        }

        .orientation-btn {
            background: var(--dark);
            padding: 6px 10px;
            margin-top: 6px;
            font-size: clamp(0.7rem, 3vw, 0.8rem);
        }

        .game-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 8px;
            width: 100%;
        }

        .stats {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            width: 100%;
            max-width: 500px;
            margin-bottom: 8px;
        }

        .stat-item {
            text-align: center;
            background-color: var(--light);
            padding: 6px 10px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: clamp(0.7rem, 3vw, 0.8rem);
            min-width: 100px;
        }

        .stat-item div:first-child {
            font-weight: bold;
            margin-bottom: 2px;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 600px) {
            .board-container {
                max-width: 100%;
            }
            
            .controls-container {
                flex-direction: column;
                align-items: center;
            }
            
            .controls, .ship-selector {
                max-width: 100%;
            }
            
            .game-board {
                max-width: 300px;
            }
        }

        /* Desktop-specific adjustments */
        @media (min-width: 601px) {
            .game-board {
                max-width: 310px;
            }
        }
    </style>
</head>
<body>
    <h1>Морской бой</h1>
    
    <div class="game-container">
        <div class="board-container">
            <h2>Ваше поле</h2>
            <div class="game-board" id="player-board"></div>
        </div>
        
        <div class="board-container">
            <h2>Противник</h2>
            <div class="game-board" id="computer-board"></div>
        </div>
    </div>
    
    <div class="controls-container">
        <div class="controls">
            <div class="message-box" id="message"></div>
            <button id="start-btn">Начать игру</button>
            <button id="restart-btn" style="display: none;">Новая игра</button>
            <button id="random-btn">Авторасстановка</button>
        </div>
        
        <div class="ship-selector" id="ship-selector">
            <h3>Размещение кораблей</h3>
            <div class="ship-list" id="ship-list">
                <!-- JS will populate this -->
            </div>
            <button class="orientation-btn" id="rotate-btn">Повернуть (Горизонтально)</button>
        </div>
    </div>
    
    <div class="game-info">
        <div class="stats">
            <div class="stat-item">
                <div>Ваши выстрелы:</div>
                <div id="player-shots">0</div>
            </div>
            <div class="stat-item">
                <div>Выстрелы противника:</div>
                <div id="computer-shots">0</div>
            </div>
            <div class="stat-item">
                <div>Осталось кораблей:</div>
                <div id="ships-remaining">10</div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game state
            const gameState = {
                phase: 'setup', // 'setup' or 'battle'
                currentPlayer: 'player',
                playerBoard: Array(10).fill().map(() => Array(10).fill(0)),
                computerBoard: Array(10).fill().map(() => Array(10).fill(0)),
                playerShots: 0,
                computerShots: 0,
                currentShip: null,
                shipOrientation: 'horizontal', // 'horizontal' or 'vertical'
                ships: [
                    { name: '4-палубный', size: 4, placed: false, count: 1 },
                    { name: '3-палубный', size: 3, placed: false, count: 2 },
                    { name: '2-палубный', size: 2, placed: false, count: 3 },
                    { name: '1-палубный', size: 1, placed: false, count: 4 }
                ],
                playerShipsRemaining: 10, // 1x4 + 2x3 + 3x2 + 4x1 = 10
                computerShipsRemaining: 10,
                totalShips: 10
            };

            // AI state
            let lastHit = null;
            let searchDirection = null;
            let possibleTargets = [];

            // DOM elements
            const playerBoard = document.getElementById('player-board');
            const computerBoard = document.getElementById('computer-board');
            const messageBox = document.getElementById('message');
            const startBtn = document.getElementById('start-btn');
            const restartBtn = document.getElementById('restart-btn');
            const randomBtn = document.getElementById('random-btn');
            const shipList = document.getElementById('ship-list');
            const rotateBtn = document.getElementById('rotate-btn');
            const shipSelector = document.getElementById('ship-selector');
            const playerShotsElement = document.getElementById('player-shots');
            const computerShotsElement = document.getElementById('computer-shots');
            const shipsRemainingElement = document.getElementById('ships-remaining');

            // Initialize the game
            initGame();

            // Event listeners
            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', restartGame);
            rotateBtn.addEventListener('click', toggleShipOrientation);
            randomBtn.addEventListener('click', placeRandomShips);

            // Functions
            function initGame() {
                // Create empty boards
                createBoard(playerBoard, false);
                createBoard(computerBoard, true);

                // Update ship list
                updateShipList();

                // Set up ship placement
                setupShipPlacement();

                // Hide computer ships
                hideComputerShips();

                // Update message
                setMessage('Разместите ваши корабли');

                // Disable start button initially
                startBtn.disabled = true;

                // Hide restart button initially
                restartBtn.style.display = 'none';

                // Reset AI state
                lastHit = null;
                searchDirection = null;
                possibleTargets = [];
                
                // Update ships remaining
                updateShipsRemaining();
            }

            function createBoard(boardElement, isComputer) {
                boardElement.innerHTML = '';
                
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        
                        if (isComputer) {
                            // Computer board cells are clickable during battle
                            cell.addEventListener('click', function() {
                                if (gameState.phase === 'battle' && gameState.currentPlayer === 'player') {
                                    handlePlayerAttack(x, y, cell);
                                }
                            });
                            
                            // Add touch event for mobile
                            cell.addEventListener('touchend', function(e) {
                                if (gameState.phase === 'battle' && gameState.currentPlayer === 'player') {
                                    e.preventDefault();
                                    handlePlayerAttack(x, y, cell);
                                }
                            });
                        } else {
                            // Player board cells are for ship placement during setup
                            cell.addEventListener('click', function() {
                                if (gameState.phase === 'setup' && gameState.currentShip) {
                                    placePlayerShip(x, y, cell);
                                }
                            });
                            
                            // Add touch event for mobile
                            cell.addEventListener('touchend', function(e) {
                                if (gameState.phase === 'setup' && gameState.currentShip) {
                                    e.preventDefault();
                                    placePlayerShip(x, y, cell);
                                }
                            });
                            
                            cell.addEventListener('mouseover', function() {
                                if (gameState.phase === 'setup' && gameState.currentShip) {
                                    highlightShipPlacement(x, y, cell);
                                }
                            });
                            
                            cell.addEventListener('mouseout', function() {
                                if (gameState.phase === 'setup' && gameState.currentShip) {
                                    clearHighlight();
                                }
                            });
                        }
                        
                        boardElement.appendChild(cell);
                    }
                }
            }

            function setupShipPlacement() {
                // Find first ship type that hasn't been fully placed
                for (const shipType of gameState.ships) {
                    const placedCount = countPlacedShipsOfType(shipType.size);
                    if (placedCount < shipType.count) {
                        gameState.currentShip = {
                            name: shipType.name,
                            size: shipType.size,
                            placed: false
                        };
                        setMessage(`Выберите позицию для ${shipType.name} корабля (${placedCount+1}/${shipType.count})`);
                        return;
                    }
                }
                
                // All ships placed
                gameState.currentShip = null;
                startBtn.disabled = false;
                setMessage('Все корабли размещены. Нажмите "Начать игру"');
            }

            function countPlacedShipsOfType(size) {
                let count = 0;
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (gameState.playerBoard[y][x] === 1) {
                            // Check if this is the start of a ship
                            if ((x === 0 || gameState.playerBoard[y][x-1] !== 1) && 
                                (y === 0 || gameState.playerBoard[y-1][x] !== 1)) {
                                // Determine ship size
                                let shipSize = 1;
                                // Check horizontal
                                let nx = x + 1;
                                while (nx < 10 && gameState.playerBoard[y][nx] === 1) {
                                    shipSize++;
                                    nx++;
                                }
                                // Check vertical if horizontal size is 1
                                if (shipSize === 1) {
                                    let ny = y + 1;
                                    while (ny < 10 && gameState.playerBoard[ny][x] === 1) {
                                        shipSize++;
                                        ny++;
                                    }
                                }
                                
                                if (shipSize === size) {
                                    count++;
                                }
                            }
                        }
                    }
                }
                return count;
            }

            function updateShipList() {
                shipList.innerHTML = '';
                
                gameState.ships.forEach(shipType => {
                    const placedCount = countPlacedShipsOfType(shipType.size);
                    
                    for (let i = 0; i < shipType.count; i++) {
                        const isPlaced = i < placedCount;
                        const shipItem = document.createElement('div');
                        shipItem.className = `ship-item ${isPlaced ? 'placed' : ''}`;
                        shipItem.innerHTML = `
                            <div class="ship-preview">
                                ${Array(shipType.size).fill().map(() => '<div class="ship-preview-cell"></div>').join('')}
                            </div>
                            ${shipType.name} ${i+1}/${shipType.count}
                            ${isPlaced ? '✓' : ''}
                        `;
                        
                        if (!isPlaced) {
                            shipItem.addEventListener('click', () => {
                                // Set this as current ship to place
                                gameState.currentShip = {
                                    name: shipType.name,
                                    size: shipType.size,
                                    placed: false
                                };
                                setMessage(`Выбран ${shipType.name}. Кликните на поле игрока, чтобы разместить`);
                            });
                            
                            // Add touch event for mobile
                            shipItem.addEventListener('touchend', (e) => {
                                e.preventDefault();
                                gameState.currentShip = {
                                    name: shipType.name,
                                    size: shipType.size,
                                    placed: false
                                };
                                setMessage(`Выбран ${shipType.name}. Кликните на поле игрока, чтобы разместить`);
                            });
                        }
                        
                        shipList.appendChild(shipItem);
                    }
                });
            }

            function toggleShipOrientation() {
                gameState.shipOrientation = gameState.shipOrientation === 'horizontal' ? 'vertical' : 'horizontal';
                rotateBtn.textContent = gameState.shipOrientation === 'horizontal' 
                    ? 'Повернуть (Горизонтально)' 
                    : 'Повернуть (Вертикально)';
            }

            let cellsToHighlight = [];

            function highlightShipPlacement(x, y, cell) {
                clearHighlight();
                
                const shipSize = gameState.currentShip.size;
                const orientation = gameState.shipOrientation;
                
                let canPlace = true;
                
                if (orientation === 'horizontal') {
                    if (x + shipSize > 10) canPlace = false;
                    
                    for (let i = 0; i < shipSize; i++) {
                        const nx = x + i;
                        // Check if out of bounds or cell already has a ship or adjacent to ship
                        if (nx >= 10 || hasShipOrAdjacent(nx, y)) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        for (let i = 0; i < shipSize; i++) {
                            const nx = x + i;
                            const ny = y;
                            const cell = playerBoard.querySelector(`[data-x="${nx}"][data-y="${ny}"]`);
                            if (cell) {
                                cell.style.backgroundColor = canPlace ? '#a3d8a3' : '#f8a5a5';
                                cellsToHighlight.push(cell);
                            }
                        }
                    }
                } else {
                    if (y + shipSize > 10) canPlace = false;
                    
                    for (let i = 0; i < shipSize; i++) {
                        const ny = y + i;
                        // Check if out of bounds or cell already has a ship or adjacent to ship
                        if (ny >= 10 || hasShipOrAdjacent(x, ny)) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        for (let i = 0; i < shipSize; i++) {
                            const nx = x;
                            const ny = y + i;
                            const cell = playerBoard.querySelector(`[data-x="${nx}"][data-y="${ny}"]`);
                            if (cell) {
                                cell.style.backgroundColor = canPlace ? '#a3d8a3' : '#f8a5a5';
                                cellsToHighlight.push(cell);
                            }
                        }
                    }
                }
                
                return canPlace;
            }

            function hasShipOrAdjacent(x, y) {
                // Check the cell itself and all adjacent cells
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10 && gameState.playerBoard[ny][nx] === 1) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function clearHighlight() {
                cellsToHighlight.forEach(cell => {
                    cell.style.backgroundColor = '';
                });
                cellsToHighlight = [];
            }

            function placePlayerShip(x, y) {
                const shipSize = gameState.currentShip.size;
                const orientation = gameState.shipOrientation;
                
                let canPlace = true;
                
                // Check if placement is valid
                if (orientation === 'horizontal') {
                    if (x + shipSize > 10) canPlace = false;
                    
                    for (let i = 0; i < shipSize; i++) {
                        const nx = x + i;
                        if (nx >= 10 || hasShipOrAdjacent(nx, y)) {
                            canPlace = false;
                            break;
                        }
                    }
                } else {
                    if (y + shipSize > 10) canPlace = false;
                    
                    for (let i = 0; i < shipSize; i++) {
                        const ny = y + i;
                        if (ny >= 10 || hasShipOrAdjacent(x, ny)) {
                            canPlace = false;
                            break;
                        }
                    }
                }
                
                if (!canPlace) {
                    setMessage('Нельзя разместить здесь! Корабли не должны соприкасаться.');
                    return;
                }
                
                // Place the ship
                if (orientation === 'horizontal') {
                    for (let i = 0; i < shipSize; i++) {
                        gameState.playerBoard[y][x + i] = 1;
                        const cell = playerBoard.querySelector(`[data-x="${x + i}"][data-y="${y}"]`);
                        cell.classList.add('ship');
                    }
                } else {
                    for (let i = 0; i < shipSize; i++) {
                        gameState.playerBoard[y + i][x] = 1;
                        const cell = playerBoard.querySelector(`[data-x="${x}"][data-y="${y + i}"]`);
                        cell.classList.add('ship');
                    }
                }
                
                setMessage(`${gameState.currentShip.name} размещен!`);
                
                // Update ship list
                updateShipList();
                
                // Set up next ship or allow game to start
                setupShipPlacement();
            }

            function placeRandomShips() {
                // Clear existing ships
                gameState.playerBoard = Array(10).fill().map(() => Array(10).fill(0));
                playerBoard.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('ship');
                });
                
                // Place ships according to classic rules
                const shipsToPlace = [
                    { size: 4, count: 1 },
                    { size: 3, count: 2 },
                    { size: 2, count: 3 },
                    { size: 1, count: 4 }
                ];
                
                shipsToPlace.forEach(shipType => {
                    for (let i = 0; i < shipType.count; i++) {
                        let placed = false;
                        while (!placed) {
                            const x = Math.floor(Math.random() * 10);
                            const y = Math.floor(Math.random() * 10);
                            const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                            
                            if (canPlaceShip(x, y, shipType.size, orientation, gameState.playerBoard)) {
                                // Place the ship
                                if (orientation === 'horizontal') {
                                    for (let j = 0; j < shipType.size; j++) {
                                        if (x + j < 10) {
                                            gameState.playerBoard[y][x + j] = 1;
                                            const cell = playerBoard.querySelector(`[data-x="${x + j}"][data-y="${y}"]`);
                                            cell.classList.add('ship');
                                        }
                                    }
                                } else {
                                    for (let j = 0; j < shipType.size; j++) {
                                        if (y + j < 10) {
                                            gameState.playerBoard[y + j][x] = 1;
                                            const cell = playerBoard.querySelector(`[data-x="${x}"][data-y="${y + j}"]`);
                                            cell.classList.add('ship');
                                        }
                                    }
                                }
                                placed = true;
                            }
                        }
                    }
                });
                
                // Update ship list
                updateShipList();
                
                // Set up next ship or allow game to start
                setupShipPlacement();
            }

            function canPlaceShip(x, y, size, orientation, board) {
                if (orientation === 'horizontal') {
                    if (x + size > 10) return false;
                    
                    for (let i = 0; i < size; i++) {
                        const nx = x + i;
                        if (nx >= 10) return false;
                        
                        // Check the cell and all adjacent cells
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const adjX = nx + dx;
                                const adjY = y + dy;
                                if (adjX >= 0 && adjX < 10 && adjY >= 0 && adjY < 10 && board[adjY][adjX] === 1) {
                                    return false;
                                }
                            }
                        }
                    }
                } else {
                    if (y + size > 10) return false;
                    
                    for (let i = 0; i < size; i++) {
                        const ny = y + i;
                        if (ny >= 10) return false;
                        
                        // Check the cell and all adjacent cells
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const adjX = x + dx;
                                const adjY = ny + dy;
                                if (adjX >= 0 && adjX < 10 && adjY >= 0 && adjY < 10 && board[adjY][adjX] === 1) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                
                return true;
            }

            function hideComputerShips() {
                // Randomly place computer ships according to classic rules
                placeComputerShips();
                
                // Computer board cells don't show ships
                const computerCells = computerBoard.querySelectorAll('.cell');
                computerCells.forEach(cell => {
                    const x = parseInt(cell.dataset.x);
                    const y = parseInt(cell.dataset.y);
                    if (gameState.computerBoard[y][x] === 1) {
                        // This is a ship cell, but we won't show it
                        cell.classList.remove('ship');
                    }
                });
            }

            function placeComputerShips() {
                gameState.computerBoard = Array(10).fill().map(() => Array(10).fill(0));
                
                const shipsToPlace = [
                    { size: 4, count: 1 },
                    { size: 3, count: 2 },
                    { size: 2, count: 3 },
                    { size: 1, count: 4 }
                ];
                
                shipsToPlace.forEach(shipType => {
                    for (let i = 0; i < shipType.count; i++) {
                        let placed = false;
                        while (!placed) {
                            const x = Math.floor(Math.random() * 10);
                            const y = Math.floor(Math.random() * 10);
                            const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                            
                            if (canPlaceShip(x, y, shipType.size, orientation, gameState.computerBoard)) {
                                // Place the ship
                                if (orientation === 'horizontal') {
                                    for (let j = 0; j < shipType.size; j++) {
                                        if (x + j < 10) {
                                            gameState.computerBoard[y][x + j] = 1;
                                        }
                                    }
                                } else {
                                    for (let j = 0; j < shipType.size; j++) {
                                        if (y + j < 10) {
                                            gameState.computerBoard[y + j][x] = 1;
                                        }
                                    }
                                }
                                placed = true;
                            }
                        }
                    }
                });
            }

            function startGame() {
                if (gameState.phase !== 'setup') return;
                
                gameState.phase = 'battle';
                gameState.currentPlayer = 'player';
                
                // Hide ship selector
                shipSelector.style.display = 'none';
                
                // Show restart button
                restartBtn.style.display = 'block';
                
                // Hide random placement button
                randomBtn.style.display = 'none';
                
                setMessage('Ваш ход! Кликните на поле противника для выстрела');
                
                // Update stats
                updateStats();
            }

            function handlePlayerAttack(x, y, cell) {
                if (cell.classList.contains('hit') || cell.classList.contains('miss')) {
                    setMessage('Вы уже стреляли в эту клетку!');
                    return;
                }
                
                gameState.playerShots++;
                updateStats();
                
                if (gameState.computerBoard[y][x] === 1) {
                    // Hit
                    cell.classList.add('hit');
                    gameState.computerBoard[y][x] = 2; // Mark as hit
                    setMessage('Попадание!');
                    
                    // Check if ship is sunk
                    if (isShipSunk(x, y, gameState.computerBoard)) {
                        gameState.computerShipsRemaining--;
                        updateShipsRemaining();
                        setMessage('Вы потопили корабль противника!');
                        
                        if (gameState.computerShipsRemaining === 0) {
                            endGame('player');
                            return;
                        }
                    }
                } else {
                    // Miss
                    cell.classList.add('miss');
                    gameState.computerBoard[y][x] = 3; // Mark as miss
                    setMessage('Промах!');
                    gameState.currentPlayer = 'computer';
                    
                    // Computer's turn after delay
                    setTimeout(computerTurn, 800);
                }
            }

            function isShipSunk(x, y, board) {
                // First find all connected ship parts
                const shipParts = [];
                const queue = [{x, y}];
                
                while (queue.length > 0) {
                    const current = queue.pop();
                    shipParts.push(current);
                    
                    // Check adjacent cells
                    const directions = [
                        { dx: 1, dy: 0 },
                        { dx: -1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: 0, dy: -1 }
                    ];
                    
                    for (const dir of directions) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        
                        if (nx >= 0 && nx < 10 && ny >= 0 && ny < 10) {
                            // If it's part of the same ship and not already in our list
                            if ((board[ny][nx] === 1 || board[ny][nx] === 2) && 
                                !shipParts.some(p => p.x === nx && p.y === ny)) {
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                }
                
                // Check if all parts are hit
                return shipParts.every(part => board[part.y][part.x] === 2);
            }

            function computerTurn() {
                if (gameState.phase !== 'battle' || gameState.currentPlayer !== 'computer') return;
                
                gameState.computerShots++;
                updateStats();
                
                const { x, y } = findComputerTarget();
                const cell = playerBoard.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                
                if (gameState.playerBoard[y][x] === 1) {
                    // Hit
                    cell.classList.add('hit');
                    gameState.playerBoard[y][x] = 2;
                    
                    // If this is first hit - remember position
                    if (!lastHit) {
                        lastHit = { x, y };
                        setMessage('Противник попал по вашему кораблю!');
                    } 
                    // If this is second hit - determine ship direction
                    else if (!searchDirection) {
                        searchDirection = {
                            dx: x - lastHit.x,
                            dy: y - lastHit.y
                        };
                        setMessage('Противник повредил ваш корабль!');
                    } 
                    // If direction is known - continue in that direction
                    else {
                        setMessage('Противник продолжает обстрел вашего корабля!');
                    }
                    
                    // Check if ship is sunk
                    if (isShipSunk(x, y, gameState.playerBoard)) {
                        gameState.playerShipsRemaining--;
                        updateShipsRemaining();
                        setMessage('Противник потопил ваш корабль!');
                        lastHit = null;
                        searchDirection = null;
                        
                        if (gameState.playerShipsRemaining === 0) {
                            endGame('computer');
                            return;
                        }
                    }
                    
                    // Computer gets another turn after hit
                    setTimeout(computerTurn, 800);
                } else {
                    // Miss
                    cell.classList.add('miss');
                    gameState.playerBoard[y][x] = 3;
                    
                    // If we were in search mode - change direction
                    if (lastHit && searchDirection) {
                        searchDirection = {
                            dx: -searchDirection.dx,
                            dy: -searchDirection.dy
                        };
                    }
                    
                    setMessage('Противник промахнулся!');
                    gameState.currentPlayer = 'player';
                }
            }

            function findComputerTarget() {
                // If there's an unfinished target (last hit)
                if (lastHit) {
                    // If search direction is not determined
                    if (!searchDirection) {
                        // Check all 4 directions from last hit
                        const directions = [
                            { dx: 1, dy: 0 },  // right
                            { dx: -1, dy: 0 }, // left
                            { dx: 0, dy: 1 },  // down
                            { dx: 0, dy: -1 }  // up
                        ];
                        
                        // Collect possible targets around the hit
                        possibleTargets = [];
                        
                        for (const dir of directions) {
                            const nx = lastHit.x + dir.dx;
                            const ny = lastHit.y + dir.dy;
                            
                            // Check if we can shoot at this cell
                            if (isValidTarget(nx, ny)) {
                                possibleTargets.push({ x: nx, y: ny });
                            }
                        }
                        
                        // If there are possible targets - choose random one
                        if (possibleTargets.length > 0) {
                            return possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
                        }
                    } 
                    // If search direction is determined
                    else {
                        // Continue shooting in this direction
                        let nx = lastHit.x + searchDirection.dx;
                        let ny = lastHit.y + searchDirection.dy;
                        
                        // While within bounds or until we find suitable target
                        while (isValidTarget(nx, ny)) {
                            return { x: nx, y: ny };
                        }
                        
                        // If no more targets in this direction - change direction
                        searchDirection = {
                            dx: -searchDirection.dx,
                            dy: -searchDirection.dy
                        };
                        
                        nx = lastHit.x + searchDirection.dx;
                        ny = lastHit.y + searchDirection.dy;
                        
                        if (isValidTarget(nx, ny)) {
                            return { x: nx, y: ny };
                        }
                    }
                    
                    // If no suitable targets found - reset search
                    lastHit = null;
                    searchDirection = null;
                }
                
                // If no active target - find random cell
                return findRandomTarget();
            }

            function isValidTarget(x, y) {
                // Check if cell is within bounds
                if (x < 0 || x >= 10 || y < 0 || y >= 10) return false;
                
                // Check if we haven't shot at this cell yet
                return gameState.playerBoard[y][x] === 0 || gameState.playerBoard[y][x] === 1;
            }

            function findRandomTarget() {
                const availableCells = [];
                
                // Collect all available cells
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        if (gameState.playerBoard[y][x] === 0 || gameState.playerBoard[y][x] === 1) {
                            availableCells.push({ x, y });
                        }
                    }
                }
                
                // Choose random cell
                return availableCells[Math.floor(Math.random() * availableCells.length)];
            }

            function endGame(winner) {
                gameState.phase = 'ended';
                
                if (winner === 'player') {
                    setMessage('Поздравляем! Вы победили!');
                } else {
                    setMessage('К сожалению, вы проиграли. Попробуйте еще раз!');
                }
                
                // Reveal all computer ships
                const computerCells = computerBoard.querySelectorAll('.cell');
                computerCells.forEach(cell => {
                    const x = parseInt(cell.dataset.x);
                    const y = parseInt(cell.dataset.y);
                    if (gameState.computerBoard[y][x] === 1) { // Ship that wasn't hit
                        cell.classList.add('ship');
                    }
                });
            }

            function restartGame() {
                // Reset game state
                gameState.phase = 'setup';
                gameState.currentPlayer = 'player';
                gameState.playerBoard = Array(10).fill().map(() => Array(10).fill(0));
                gameState.computerBoard = Array(10).fill().map(() => Array(10).fill(0));
                gameState.playerShots = 0;
                gameState.computerShots = 0;
                gameState.currentShip = null;
                gameState.shipOrientation = 'horizontal';
                gameState.playerShipsRemaining = 10;
                gameState.computerShipsRemaining = 10;
                
                gameState.ships.forEach(shipType => {
                    shipType.placed = false;
                });
                
                // Re-initialize the game
                playerBoard.innerHTML = '';
                computerBoard.innerHTML = '';
                
                createBoard(playerBoard, false);
                createBoard(computerBoard, true);
                
                updateShipList();
                setupShipPlacement();
                hideComputerShips();
                
                setMessage('Разместите ваши корабли');
                
                // Show ship selector again
                shipSelector.style.display = 'block';
                
                // Hide restart button
                restartBtn.style.display = 'none';
                
                // Show random placement button
                randomBtn.style.display = 'block';
                
                // Disable start button
                startBtn.disabled = true;
                
                // Reset orientation button text
                gameState.shipOrientation = 'horizontal';
                rotateBtn.textContent = 'Повернуть (Горизонтально)';
                
                // Update stats
                updateStats();
                updateShipsRemaining();
                
                // Reset AI state
                lastHit = null;
                searchDirection = null;
                possibleTargets = [];
            }

            function setMessage(text) {
                messageBox.textContent = text;
            }

            function updateStats() {
                playerShotsElement.textContent = gameState.playerShots;
                computerShotsElement.textContent = gameState.computerShots;
            }
            
            function updateShipsRemaining() {
                shipsRemainingElement.textContent = `${gameState.computerShipsRemaining}/${gameState.totalShips}`;
            }
        });
    </script>
</body>
</html>
